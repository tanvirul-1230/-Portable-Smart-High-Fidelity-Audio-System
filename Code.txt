/*
  Portable Smart & High-Fidelity Audio System
  ESP32 Firmware
  
  This code integrates all core hardware based on your project diagram and README:
  - ESP32 for main control
  - Bluetooth (A2DP) for wireless audio
  - I2S output to a PCM5102A DAC
  - CD4052 MUX to switch between BT, AUX, and MIC
  - SSD1306 OLED (I2C) for display
  - Rotary Encoder for volume control and mode switching
*/

// === 1. INCLUDE LIBRARIES ===

// --- I2C Libraries ---
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// --- Bluetooth & Audio Libraries ---
#include "BluetoothA2DPSink.h" // ESP32 Bluetooth Library
#include "AudioTools.h"         // Audio pipeline tools

// --- UI Library ---
// We will read the rotary encoder manually to match your diagram
// (Using AiEsp32RotaryEncoder library can also be an option)
// NOTE: For simplicity, this code uses manual polling.

// === 2. LIBRARY INSTALLATION (IMPORTANT) ===
/*
  You MUST install these libraries via the Arduino IDE Library Manager:
  1. Adafruit GFX Library
  2. Adafruit SSD1306
  3. ESP32-A2DP (from pschatzmann)
  4. AudioTools (from pschatzmann)
*/

// === 3. PIN DEFINITIONS (from your hand-drawn diagram) ===

// --- I2C (OLED) ---
#define I2C_SDA_PIN 21
#define I2C_SCL_PIN 22

// --- I2S (to PCM5102A DAC) ---
#define I2S_BCLK_PIN  23 // BCK on diagram
#define I2S_LRCK_PIN  19 // LRCK on diagram
#define I2S_DIN_PIN   18 // DIN on diagram

// --- Rotary Encoder ---
#define ENCODER_CLK_PIN 33 // DT on diagram
#define ENCODER_DT_PIN  25 // CLK on diagram (You have these swapped on diagram label vs pin, I'll follow diagram's DT->33, CLK->25)
#define ENCODER_SW_PIN  32 // SW on diagram

// --- CD4052 MUX (Audio Source Switch) ---
#define MUX_S0_PIN    12 // A on diagram
#define MUX_S1_PIN    14 // B on diagram
#define MUX_INH_PIN   13 // EN (Enable/Inhibit) on diagram

// === 4. GLOBAL OBJECTS & VARIABLES ===

// --- Audio ---
BluetoothA2DPSink a2dp_sink;
I2SStream i2s_out;
StreamCopy copier(i2s_out, a2dp_sink); // Copies data from A2DP to I2S

// --- Display ---
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

// --- System State ---
enum AudioSource { BLUETOOTH, AUX, MIC };
AudioSource currentSource = BLUETOOTH;
int volume = 80; // 0-127 (A2DP volume)
bool isConnected = false;

// --- Encoder State (for manual reading) ---
int lastClkState;
unsigned long lastButtonPress = 0;

// === 5. SETUP ===

void setup() {
  Serial.begin(115200);
  Serial.println("Starting Smart Audio System...");

  // --- Initialize MUX Pins ---
  pinMode(MUX_S0_PIN, OUTPUT);
  pinMode(MUX_S1_PIN, OUTPUT);
  pinMode(MUX_INH_PIN, OUTPUT);
  digitalWrite(MUX_INH_PIN, HIGH); // Disable MUX initially

  // --- Initialize Encoder Pins ---
  pinMode(ENCODER_CLK_PIN, INPUT_PULLUP);
  pinMode(ENCODER_DT_PIN, INPUT_PULLUP);
  pinMode(ENCODER_SW_PIN, INPUT_PULLUP);
  lastClkState = digitalRead(ENCODER_CLK_PIN); // Store initial CLK state

  // --- Initialize I2C and OLED ---
  Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN);
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // 0x3C is common address
    Serial.println(F("SSD1306 allocation failed"));
    for (;;);
  }
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);
  display.setCursor(10, 20);
  display.println("Smart Audio System");
  display.setCursor(35, 35);
  display.println("Starting...");
  display.display();
  delay(2000);

  // --- Initialize I2S Audio Output ---
  auto config = i2s_out.defaultConfig(TX_MODE);
  config.pin_bck = I2S_BCLK_PIN;
  config.pin_ws = I2S_LRCK_PIN; // WS is LRCK
  config.pin_data = I2S_DIN_PIN;
  config.sample_rate = 44100;
  config.bits_per_sample = 16;
  config.channels = 2;
  i2s_out.begin(config);

  // --- Initialize Bluetooth ---
  // Set the I2S stream as the output for Bluetooth data
  a2dp_sink.set_stream_out(&i2s_out);
  a2dp_sink.set_on_connection_state_changed(connection_state_changed);
  a2dp_sink.set_on_audio_state_changed(audio_state_changed);
  a2dp_sink.set_volume(volume);
  a2dp_sink.start("ESP32-HiFi-Speaker");

  // --- Set Initial State ---
  setMuxSource(currentSource);
  updateDisplay();
}

// === 6. MAIN LOOP ===

void loop() {
  // 1. Read the Rotary Encoder
  readEncoder();

  // 2. Read the Encoder Button
  readEncoderButton();

  // 3. Keep the audio flowing (handled by libraries in background)
  // `set_stream_out` handles this automatically.
  // If we were not using `set_stream_out`, we would use:
  // copier.copy();
}

// === 7. HELPER FUNCTIONS ===

// --- MUX Control ---
void setMuxSource(AudioSource source) {
  digitalWrite(MUX_INH_PIN, HIGH); // Disable MUX while changing
  delay(1);

  switch (source) {
    case BLUETOOTH: // Channel 1 (X0, Y0 on diagram)
      digitalWrite(MUX_S0_PIN, LOW);
      digitalWrite(MUX_S1_PIN, LOW);
      break;

    case AUX: // Channel 2 (X1, Y1 on diagram)
      digitalWrite(MUX_S0_PIN, HIGH);
      digitalWrite(MUX_S1_PIN, LOW);
      break;

    case MIC: // Channel 3 (X2, Y2 on diagram)
      digitalWrite(MUX_S0_PIN, LOW);
      digitalWrite(MUX_S1_PIN, HIGH);
      break;
    
    // Channel 4 (X3, Y3) would be S0=HIGH, S1=HIGH
  }

  delay(1);
  digitalWrite(MUX_INH_PIN, LOW); // Re-enable MUX
  Serial.print("Source set to: ");
  Serial.println(source);
}

// --- Display Update ---
void updateDisplay() {
  display.clearDisplay();
  display.setTextSize(2);
  
  // --- Draw Volume ---
  display.setCursor(0, 8);
  display.print("Vol:");
  display.print(map(volume, 0, 127, 0, 100)); // Show as 0-100%
  
  // --- Draw Mode ---
  display.setCursor(0, 40);
  display.print("Mode: ");
  switch (currentSource) {
    case BLUETOOTH:
      display.print("BT");
      if (!isConnected) {
        display.setTextSize(1);
        display.setCursor(90, 48);
        display.print("(Wait)");
      }
      break;
    case AUX:
      display.print("AUX");
      break;
    case MIC:
      display.print("MIC");
      break;
  }
  
  display.display();
}

// --- Rotary Encoder Reading ---
void readEncoder() {
  int clkState = digitalRead(ENCODER_CLK_PIN);
  if (clkState != lastClkState && clkState == LOW) {
    // CLK has changed from HIGH to LOW (a "tick")
    if (digitalRead(ENCODER_DT_PIN) == LOW) {
      // DT is also LOW -> Clockwise -> Volume UP
      volume += 4;
      if (volume > 127) volume = 127;
    } else {
      // DT is HIGH -> Counter-Clockwise -> Volume DOWN
      volume -= 4;
      if (volume < 0) volume = 0;
    }
    
    Serial.print("Volume: ");
    Serial.println(volume);
    a2dp_sink.set_volume(volume); // Set digital volume
    updateDisplay();
  }
  lastClkState = clkState;
}

void readEncoderButton() {
  // Simple debounce
  if (digitalRead(ENCODER_SW_PIN) == LOW && (millis() - lastButtonPress > 500)) {
    lastButtonPress = millis();
    
    // Cycle to the next audio source
    if (currentSource == BLUETOOTH) {
      currentSource = AUX;
    } else if (currentSource == AUX) {
      currentSource = MIC;
    } else {
      currentSource = BLUETOOTH;
    }
    
    setMuxSource(currentSource);
    updateDisplay();
  }
}

// === 8. BLUETOOTH CALLBACKS ===
void connection_state_changed(esp_a2d_connection_state_t state, void *ptr){
  if (state == ESP_A2D_CONNECTION_STATE_CONNECTED) {
    Serial.println("A2DP Connected!");
    isConnected = true;
  } else {
    Serial.println("A2DP Disconnected");
    isConnected = false;
  }
  // We can't call updateDisplay() from this core,
  // so we'd need a flag for the main loop.
  // For now, it will update on next volume/mode change.
}

void audio_state_changed(esp_a2d_audio_state_t state, void *ptr){
  if (state == ESP_A2D_AUDIO_STATE_STARTED){
    Serial.println("A2DP Audio Playing");
  } else {
    Serial.println("A2DP Audio Stopped");
  }
}
